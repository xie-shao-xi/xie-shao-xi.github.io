<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>尝试便捷更新博客</title>
      <link href="/2025/12/27/%E5%B0%9D%E8%AF%95%E4%BE%BF%E6%8D%B7%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/12/27/%E5%B0%9D%E8%AF%95%E4%BE%BF%E6%8D%B7%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​如题，开始搭建博客之后，了解到<code>hexo</code>新建博客和更新博客啥的很麻烦，所以想着能不能在线上完成这些操作，在线发布博客内容，更新，部署啥的</p><h3 id="二、初步尝试"><a href="#二、初步尝试" class="headerlink" title="二、初步尝试"></a>二、初步尝试</h3><ol><li><p>使用node创建一个简单的服务端，然后接收到请求时，执行对应的命令</p><pre class="line-numbers language-none"><code class="language-none">const http &#x3D; require(&#39;http&#39;)const server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;    if(req.url &#x3D;&#x3D; &quot;&#x2F;favicon.ico&quot;) return;        console.log(&#39;ok&#39;, req.url); &#x2F;&#x2F; 每次请求都会执行一次回调函数中的语句        const url &#x3D; req.url.split(&#39;?&#39;)[0]    const method &#x3D; req.method        if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;start&#39; &amp;&amp; method &#x3D;&#x3D;&#x3D; &#39;GET&#39;) &#123;    &#x2F;&#x2F; 执行命令    &#125; else  &#123;        res.end(&#39;404&#39;)    &#125;&#125;)server.listen(2000) &#x2F;&#x2F; 监听2000端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>node执行<code>cmd</code>脚本命令（现在windows上尝试）</p><pre class="line-numbers language-none"><code class="language-none">const &#123; exec &#125; &#x3D; require(&#39;child_process&#39;);const test &#x3D; () &#x3D;&gt; &#123;    const workDir &#x3D; &#39;D:\\project\\blog&#39;;    const cmd &#x3D; &#39;hexo s&#39;;    &#x2F;&#x2F; 执行命令    exec(cmd, &#123; cwd: workDir &#125;, (error, stdout, stderr) &#x3D;&gt; &#123;        let res;        if (error) &#123;            res &#x3D; &#96;error: $&#123;error&#125;&#96;        &#125; else if (stderr) &#123;            res &#x3D; &#96;stderr: $&#123;stderr&#125;&#96;        &#125; else &#123;            res &#x3D; &#96;stdout: $&#123;stdout&#125;&#96;        &#125;        console.log(res);    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>exec执行还是能执行的，不过我这里用的<code>hexo s</code>，所以需要考虑关闭程序的问题，用exec没办法，查到spawn能获取执行的程序的pid，然后就改成用spawn</p><pre class="line-numbers language-none"><code class="language-none">let hexoServer;const startServer &#x3D; () &#x3D;&gt; &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        const cmd &#x3D; &#39;hexo s&#39;;        const cwd &#x3D; &#39;D:\\project\\blog&#39;;        let newHexoServer &#x3D; spawn(cmd, [], &#123;            cwd,            &#x2F;&#x2F; 不设置这个，在window上无法执行            shell: process.platform &#x3D;&#x3D;&#x3D; &#39;win32&#39;        &#125;)        newHexoServer.stdout.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;            let res &#x3D; JSON.stringify(data.toString())            console.log(&quot;stdout.on&quot; + res);            if(res.includes(&quot;has been used&quot;)) &#123;                reject(res)            &#125;else &#123;                hexoServer &#x3D; newHexoServer;                resolve(&quot;start success!&quot;)            &#125;        &#125;);        newHexoServer.stderr.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;            console.error(JSON.stringify(data.toString()));            reject(&quot;start error,stderr!&quot; + JSON.stringify(data))        &#125;);        newHexoServer.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;            console.error(JSON.stringify(err));            reject(&quot;start error,onerror!&quot; + JSON.stringify(err))        &#125;);        newHexoServer.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;            console.log(&#96;Child exited with code $&#123;code&#125;&#96;);        &#125;);    &#125;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后发现一个问题，<code>stdout.on</code>回调是执行多次的，程序执行后一行打印一次，想了个笨方法，用定时器记录，然后记录过程判断，是不是出现了成功的文案，超过1秒没有继续则默认失败</p><pre class="line-numbers language-none"><code class="language-none">const startServer &#x3D; () &#x3D;&gt; &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        const cmd &#x3D; &#39;hexo s&#39;;        const cwd &#x3D; &#39;D:\\project\\blog&#39;;        let newHexoServer &#x3D; spawn(cmd, [], &#123;            cwd,            shell: process.platform &#x3D;&#x3D;&#x3D; &#39;win32&#39;        &#125;)        &#x2F;&#x2F; 记录打印文本和倒计时        let allOut &#x3D; &quot;&quot;, outTimer;        newHexoServer.stdout.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;            allOut +&#x3D; data.toString();            clearTimeout(outTimer);            &#x2F;&#x2F; 若出现成功的标识文本，则结束并返回            if(allOut.includes(&quot;Hexo is running at&quot;)) &#123;                console.log(allOut)                &#x2F;&#x2F; 记录程序信息，方便后续关闭                hexoServer &#x3D; newHexoServer;                resolve(&quot;start success!&quot;)            &#125;else &#123;                outTimer &#x3D; setTimeout(() &#x3D;&gt; &#123;                    reject(allOut)                &#125;, 1000)            &#125;        &#125;);        &#x2F;&#x2F; 记录失败打印文本和失败倒计时        let allErrOut &#x3D; &quot;&quot;, outErrTimer;        newHexoServer.stderr.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;            allErrOut +&#x3D; data.toString();            clearTimeout(outErrTimer);            outErrTimer &#x3D; setTimeout(() &#x3D;&gt; &#123;                reject(allErrOut)            &#125;, 2000)        &#125;);        newHexoServer.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;            console.error(JSON.stringify(err));            reject(&quot;start error,onerror!&quot; + JSON.stringify(err))        &#125;);        newHexoServer.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;            console.log(&#96;Child exited with code $&#123;code&#125;&#96;);        &#125;);    &#125;)&#125;const stopServer &#x3D; () &#x3D;&gt; &#123;    if(!hexoServer) return Promise.resolve(&quot;had closed&quot;);        return new Promise((resolve, reject) &#x3D;&gt; &#123;        let pid &#x3D; hexoServer.pid;        exec(&#96;taskkill &#x2F;PID $&#123;pid&#125; &#x2F;T &#x2F;F&#96;, &#123; windowsHide: false &#125;, (error, stdout, stderr) &#x3D;&gt; &#123;            if(error) &#123;                console.log(&quot;error: &quot; + JSON.stringify(error))                reject(&quot;close fail!&quot;)            &#125;else if(stderr) &#123;                console.log(&quot;stderr: &quot; + stderr)                reject(&quot;close fail!&quot;)            &#125;else &#123;                resolve(&quot;close success!&quot; + stdout)            &#125;            hexoServer &#x3D; undefined;        &#125;);    &#125;)&#125;&#x2F;&#x2F; 调用if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;start&#39; &amp;&amp; method &#x3D;&#x3D;&#x3D; &#39;GET&#39;) &#123;    startServer().then((result) &#x3D;&gt; &#123;        res.end(result)    &#125;).catch(err &#x3D;&gt; &#123;        console.log(&#39;&#x2F;start is error&#x3D;&#x3D;&#x3D;&#39; + JSON.stringify(err));        res.end(err)    &#125;)&#125; else if (url &#x3D;&#x3D;&#x3D; &#39;&#x2F;stop&#39; &amp;&amp; method &#x3D;&#x3D;&#x3D; &#39;GET&#39;) &#123;    stopServer().then((result) &#x3D;&gt; &#123;        res.end(result)    &#125;).catch(err &#x3D;&gt; &#123;        console.log(&#39;&#x2F;stop is error&#x3D;&#x3D;&#x3D;&#39; + JSON.stringify(err));        res.end(err)    &#125;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后其他问题，比如，使用exec会出现文字乱码，代码不够美观，等后续优化吧</p></li></ol><h3 id="二、简单的后台"><a href="#二、简单的后台" class="headerlink" title="二、简单的后台"></a>二、简单的后台</h3><p>1. </p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3><pre class="line-numbers language-none"><code class="language-none">本来想着博客里面附带在线编辑、更新、部署功能的，但是好像不太合适先弄个简单的后台，然后在里面内置一些关于博客的操作吧，后续看看有没有更好的方案优化代码解决乱码问题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器（centos）尝试hexo和踩坑</title>
      <link href="/2025/12/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88centos%EF%BC%89%E5%B0%9D%E8%AF%95hexo%E5%92%8C%E8%B8%A9%E5%9D%91/"/>
      <url>/2025/12/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88centos%EF%BC%89%E5%B0%9D%E8%AF%95hexo%E5%92%8C%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h3 id="一、初始化hexo"><a href="#一、初始化hexo" class="headerlink" title="一、初始化hexo"></a>一、初始化hexo</h3><ol><li>准备环境</li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 官网https:&#x2F;&#x2F;hexo.io&#x2F;zh-cn&#x2F;&#x2F; 下载gitsudo yum install git-core&#x2F;&#x2F; 下载nodejssudo yum install -y nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>初始化hexo</li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 下载安装hexo脚手架npm install -g hexo-cli&#x2F;&#x2F; 下载hexonpm install hexo&#x2F;&#x2F; 初始化项目（项目名blog，可自定义）hexo init blog&#x2F;&#x2F; 进入项目cd blog&#x2F;&#x2F; 下载依赖npm install&#x2F;&#x2F; 本地执行博客hexo server &#x2F;&#x2F; 简写命令 hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>成功的话，访问本地4000端口即可</li></ol><h3 id="二、更新到github"><a href="#二、更新到github" class="headerlink" title="二、更新到github"></a>二、更新到github</h3><ol><li><p>注册github账号</p></li><li><p>新建仓库（create repository）</p><img src="/2025/12/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88centos%EF%BC%89%E5%B0%9D%E8%AF%95hexo%E5%92%8C%E8%B8%A9%E5%9D%91/20241226161546240.png" class="" title="image-20241226161546240"><p>一般仓库名是github用户名.github.io，方便后面部署后直接能访问</p></li><li><p>github添加ssh公钥</p><p>头像-&gt;settings-&gt;SSH and GPG keys</p><p>将本地创建的公钥添加进去</p></li><li><p>本地项目下载依赖，方便更新</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>_config.yml配置更新相关内容</p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repository: git@github.com:用户名&#x2F;用户名.github.io.git  branch: main # 可以先看看新建的仓库默认分支是master还是main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>清除缓存后，执行部署</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 第一次部署可以不执行hexo clean&#x2F;&#x2F; hexo deploy的简写hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>访问<a href="https://github用户名.github.io/">https://github用户名.github.io</a></p></li></ol><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3><pre class="line-numbers language-none"><code class="language-none">在线编辑？更新到服务器弄个域名选个主题添加需要的功能<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><h4 id="（一）、hexo、nodejs版本冲突"><a href="#（一）、hexo、nodejs版本冲突" class="headerlink" title="（一）、hexo、nodejs版本冲突"></a>（一）、hexo、nodejs版本冲突</h4><ol><li>下载脚手架时报错</li></ol><pre class="line-numbers language-none"><code class="language-none">报错：Failed at the hexo-util@3.3.0 postinstall script...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>原因</strong>：centos8.6，执行<code>sudo yum install -y nodejs</code>下载的nodejs版本为10.x，与最新的hexo-cli冲突</p><p><strong>尝试解决</strong>：根据官网hexo版本和nodejs对应关系，加上hexo-cli发布时间和hexo版本发布时间，推算需要的hexo-cli版本和hexo版本（原先打算使用nvm升级nodejs版本，但服务器下载一直卡住，就只能换方案）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 下载hexo-cli时，指定版本，成功下载脚手架npm install -g hexo-cli@xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>下载hexo时报错</li></ol><pre class="line-numbers language-none"><code class="language-none">报错：TypeError: line.matchAll is not a function...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>原因</strong>：该方法至少node12.x才能运行，即nodejs版本还是太低</p><p><strong>尝试解决</strong>：删除原有nodejs，下载新的指定版本的（因直接升级失败，且默认下载就是低版本的）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;查找已下载的nodejs文件dnf list installed | grep nodejs&#x2F;&#x2F; 删除，上述命令执行后出现三列，第一列即是删除的包名sudo dnf remove nodexxx&#x2F;&#x2F; 下载指定版本node（14.x即是14版本）curl -fsSL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_14.x | sudo bash -sudo yum install -y nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/11/25/hello-world/"/>
      <url>/2024/11/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
